import type { ReactElement } from "react";
import { ConcurrentRoot } from "react-reconciler/constants";

import { Tag } from "./constants";
import { HostElement } from "./host-element";
import type { Container } from "./reconciler";
import { TestReconciler } from "./reconciler";

// Refs:
// https://github.com/facebook/react/blob/main/packages/react-test-renderer/src/ReactFiberConfigTestHost.js
// https://github.com/facebook/react/blob/main/packages/react-noop-renderer/src/createReactNoop.js
// https://github.com/facebook/react/blob/main/packages/react-native-renderer/src/ReactFiberConfigFabric.js

const defaultCreateMockNode = () => ({});

const defaultOnUncaughtError = (error: unknown, errorInfo: ErrorInfo) => {
  console.error("Uncaught error:", error, errorInfo);
};
const defaultOnCaughtError = (error: unknown, errorInfo: ErrorInfo) => {
  console.error("Caught error:", error, errorInfo);
};
const defaultOnRecoverableError = (error: unknown, errorInfo: ErrorInfo) => {
  console.error("Recoverable error:", error, errorInfo);
};

export type RootOptions = {
  /** Types of valid text components. */
  textComponents?: string[];

  createNodeMock?: (element: ReactElement) => object;

  /** Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack. */
  onCaughtError?: ErrorHandler;

  /** Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown, and an errorInfo object containing the componentStack. */
  onUncaughtError?: ErrorHandler;

  /** Callback called when React automatically recovers from errors. Called with an error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause. */
  onRecoverableError?: ErrorHandler;

  /** A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. */
  identifierPrefix?: string;

  isStrictMode?: boolean;
};

export type ErrorHandler = (error: unknown, errorInfo: ErrorInfo) => void;
export type ErrorInfo = {
  componentStack: string;
};

export type Root = {
  render: (element: ReactElement) => void;
  unmount: () => void;
  container: HostElement;
};

export function createRoot(options?: RootOptions): Root {
  let container: Container | null = {
    tag: Tag.Container,
    parent: null,
    children: [],
    isHidden: false,
    config: {
      textComponents: options?.textComponents,
      createNodeMock: options?.createNodeMock ?? defaultCreateMockNode,
    },
  };

  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
  let containerFiber = TestReconciler.createContainer(
    container,
    ConcurrentRoot,
    null, // hydrationCallbacks
    options?.isStrictMode ?? false,
    false, // concurrentUpdatesByDefaultOverride
    options?.identifierPrefix ?? "",
    options?.onUncaughtError ?? defaultOnUncaughtError,
    options?.onCaughtError ?? defaultOnCaughtError,
    // @ts-expect-error missing types in @types/react-reconciler 0.31
    options?.onRecoverableError ?? defaultOnRecoverableError,
    null, // transitionCallbacks
  );

  const render = (element: ReactElement) => {
    TestReconciler.updateContainer(element, containerFiber, null, null);
  };

  const unmount = () => {
    if (container == null) {
      return;
    }

    TestReconciler.updateContainer(null, containerFiber, null, null);

    containerFiber = null;
    container = null;
  };

  return {
    render,
    unmount,
    get container(): HostElement {
      if (container == null) {
        throw new Error("Can't access .container on unmounted test renderer");
      }

      return HostElement.fromInstance(container);
    },
  };
}
